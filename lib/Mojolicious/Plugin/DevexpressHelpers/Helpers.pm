package Mojolicious::Plugin::DevexpressHelpers::Helpers;
use Modern::Perl;
use Mojo::ByteStream;
use Mojo::JSON qw(encode_json);
=head1 SUBROUTINES/METHODS

=cut

=head2 new

	$c->stash( 'dxHelper' => Mojolicous::Plugin::DevexpressHelpers::Helpers->new );

=cut
sub out{
	my $tag = shift;
	return Mojo::ByteStream->new($tag);
}

sub new{
	my $class = shift;
	my $self = bless { 
			next_id => 1,
			bindings => '',
		}, $class;
	return $self;
}

sub add_binding{
	my $self = shift;
	$self->{bindings} .= join "\n", @_;
}

sub next_id{
	my $self = shift;
	return "dxctl".($self->{next_id}++);
}

sub new_id{
	my ($c, $attrs) = @_;
	#should compute a new uniq id 
	$c->stash('dxHelper')->next_id;
}

sub dxbind{
	my ($c, $control, $id, $attrs, $extensions) = @_;
	#should return html code to be associated to the control
	my $binding = '$("#'.$id.'").'.$control.'({';
    my @options;
    for my $k ( sort keys %$attrs){
		my $v = $attrs->{$k};
		if(ref($v) eq 'SCALAR'){
			#unref protected scalar
			$v = $$v;
		}
		elsif ($v!~/^\s*(?:function\s*\()/) {
			$v =  encode_json $v;
		}
		push @options, "$k: $v";
    }
    $binding .= join ",\n", @options;
    $binding .= '});';
	#append some extensions (eg: dxdatagrid)
	$binding .= join ";\n", @$extensions if defined $extensions;
	$c->stash('dxHelper')->add_binding($binding);
	#TODO: Possible extension: may add html attributs or sub content from special attributs
	out '<div id="'.$id.'"></div>';
}

sub parse_attributs{
	my $c = shift;
	my @implicit_args = @{shift()};
	my %attrs;
	IMPLICIT_ARGUMENT:
	while(defined($_[0]) and ref($_[0]) eq ''){
		$attrs{ shift @implicit_args } = shift @_;
	}
	if(my $args = shift){
		if(ref($args) eq 'HASH'){
			NAMED_ARGUMENT:
			while(my($k,$v)=each %$args){
				$attrs{$k} = $v;
			}
		}
	}
	return \%attrs;
}	

=head2 dxbutton $text, $onclick || \%options

	%= dxbutton 'My button' => '/some/url'
	
	%= dxbutton 'My button' => q{ function (){ alert('onClick!'); } }
	
	%= dxbutton 'My button' => q{ function (){ alert('onClick!'); } }, { type => 'danger', icon => 'user' }

=cut

sub dxbutton {
    my $c = shift;
	my $attrs = parse_attributs( $c, [qw(text onClick type)], @_ );
	my $id = new_id( $c, $attrs );	
	dxbind( $c, 'dxButton' => $id => $attrs);
}

=head2 dxdatagrid [ $datasource, ] \%opts

	%= dxdatagrid '/products.json'
	
	%= dxdatagrid '/products.json', { columns => [qw( name description price )] }

=cut

sub dxdatagrid{
	my $c = shift;
	my $attrs = parse_attributs( $c, [qw(dataSource)], @_ );
	my $id = new_id( $c, $attrs );
	my @extensions;
	#dxbind( $c, 'dxDataGrid' => $id => $attrs, [ $dataSource ]);
	if (ref($attrs->{dataSource}) eq '') {
		my $dataSource = delete $attrs->{dataSource};
		#push @extensions, '$.getJSON("' . $dataSource . '",function(data){$("#'.$id.'").dxDataGrid({ dataSource: data });});';
		#$attrs->{dataSource} = \'[]';	#protect string to be "stringified" within dxbind

		#\"" is to protect string to be "stringified" within dxbind
		$attrs->{dataSource} = \"{store:{type:'odata',url:'$dataSource'}}";
	}
	dxbind( $c, 'dxDataGrid' => $id => $attrs, \@extensions);
}

=head2 dxbuild

Build the binding between jQuery and divs generated by plugin helpers such as dxbutton.
It is should to be called in your template just before you close the body tag.

	<body>
		...
		%= dxbuild
	</body>

=cut

sub dxbuild {
	my $c = shift;
	my $dxhelper = $c->stash('dxHelper') or return;
	if($dxhelper->{bindings}){
		out '<script language="javascript">$(function(){'.$dxhelper->{bindings}.'});</script>';
	}
}

1;